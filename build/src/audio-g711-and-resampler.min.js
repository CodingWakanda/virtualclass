'use strict';function Resampler(b,a,c,d,e){this.fromSampleRate=b;this.toSampleRate=a;this.channels=c|0;this.outputBufferSize=d;this.noReturn=!!e;this.initialize()}
Resampler.prototype.initialize=function(){if(0<this.fromSampleRate&&0<this.toSampleRate&&0<this.channels)this.fromSampleRate==this.toSampleRate?(this.resampler=this.bypassResampler,this.ratioWeight=1):(this.fromSampleRate<this.toSampleRate?(this.compileLinearInterpolationFunction(),this.lastWeight=1):(this.compileMultiTapFunction(),this.tailExists=!1,this.lastWeight=0),this.ratioWeight=this.fromSampleRate/this.toSampleRate,this.initializeBuffers());else throw Error("Invalid settings specified for the resampler.");
};Resampler.prototype.compileLinearInterpolationFunction=function(){let b=`var bufferLength = buffer.length;\
	var outLength = this.outputBufferSize;\
	if ((bufferLength % ${this.channels}) == 0) {\
		if (bufferLength > 0) {\
			var ratioWeight = this.ratioWeight;\
			var weight = this.lastWeight;\
			var firstWeight = 0;\
			var secondWeight = 0;\
			var sourceOffset = 0;\
			var outputOffset = 0;\
			var outputBuffer = this.outputBuffer;\
			for (; weight < 1; weight += ratioWeight) {\
				secondWeight = weight % 1;\
				firstWeight = 1 - secondWeight;`;for(var a=0;a<this.channels;++a)b+=`outputBuffer[outputOffset++] = (this.lastOutput[${a}] * firstWeight) + (buffer[${a}] * secondWeight);`;b+=`}\
			weight -= 1;\
			for (bufferLength -= ${this.channels}, sourceOffset = Math.floor(weight) * ${this.channels}; outputOffset < outLength && sourceOffset < bufferLength;) {\
				secondWeight = weight % 1;\
				firstWeight = 1 - secondWeight;`;for(a=0;a<this.channels;++a)b+=`outputBuffer[outputOffset++] = (buffer[sourceOffset${0<a?` + ${a}`:""}] * firstWeight) + (buffer[sourceOffset + ${this.channels+a}] * secondWeight);`;b+=`weight += ratioWeight;\
				sourceOffset = Math.floor(weight) * ${this.channels};\
			}`;for(a=0;a<this.channels;++a)b+=`this.lastOutput[${a}] = buffer[sourceOffset++];`;this.resampler=Function("buffer",b+'this.lastWeight = weight % 1;\t\t\treturn this.bufferSlice(outputOffset);\t\t}\t\telse {\t\t\treturn (this.noReturn) ? 0 : [];\t\t}\t}\telse {\t\tthrow(new Error("Buffer was of incorrect sample length."));\t}')};Resampler.prototype.compileMultiTapFunction=function(){let b=`var bufferLength = buffer.length;\
	var outLength = this.outputBufferSize;\
	if ((bufferLength % ${this.channels}) == 0) {\
		if (bufferLength > 0) {\
			var ratioWeight = this.ratioWeight;\
			var weight = 0;`;for(var a=0;a<this.channels;++a)b+=`var output${a} = 0;`;b+="var actualPosition = 0;\t\t\tvar amountToNext = 0;\t\t\tvar alreadyProcessedTail = !this.tailExists;\t\t\tthis.tailExists = false;\t\t\tvar outputBuffer = this.outputBuffer;\t\t\tvar outputOffset = 0;\t\t\tvar currentPosition = 0;\t\t\tdo {\t\t\t\tif (alreadyProcessedTail) {\t\t\t\t\tweight = ratioWeight;";for(a=0;a<this.channels;++a)b+=`output${a} = 0;`;b+="}\t\t\t\telse {\t\t\t\t\tweight = this.lastWeight;";for(a=0;a<
this.channels;++a)b+=`output${a} = this.lastOutput[${a}];`;b+="alreadyProcessedTail = true;\t\t\t\t}\t\t\t\twhile (weight > 0 && actualPosition < bufferLength) {\t\t\t\t\tamountToNext = 1 + actualPosition - currentPosition;\t\t\t\t\tif (weight >= amountToNext) {";for(a=0;a<this.channels;++a)b+=`output${a} += buffer[actualPosition++] * amountToNext;`;b+="currentPosition = actualPosition;\t\t\t\t\t\tweight -= amountToNext;\t\t\t\t\t}\t\t\t\t\telse {";for(a=0;a<this.channels;++a)b+=`output${a} += buffer[actualPosition${0<
a?` + ${a}`:""}] * weight;`;b+="currentPosition += weight;\t\t\t\t\t\tweight = 0;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t}\t\t\t\tif (weight == 0) {";for(a=0;a<this.channels;++a)b+=`outputBuffer[outputOffset++] = output${a} / ratioWeight;`;b+="}\t\t\t\telse {\t\t\t\t\tthis.lastWeight = weight;";for(a=0;a<this.channels;++a)b+=`this.lastOutput[${a}] = output${a};`;this.resampler=Function("buffer",b+'this.tailExists = true;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t} while (actualPosition < bufferLength && outputOffset < outLength);\t\t\treturn this.bufferSlice(outputOffset);\t\t}\t\telse {\t\t\treturn (this.noReturn) ? 0 : [];\t\t}\t}\telse {\t\tthrow(new Error("Buffer was of incorrect sample length."));\t}')};
Resampler.prototype.bypassResampler=function(b){return this.noReturn?(this.outputBuffer=b,b.length):b};Resampler.prototype.bufferSlice=function(b){if(this.noReturn)return b;try{return this.outputBuffer.subarray(0,b)}catch(a){try{return this.outputBuffer.length=b,this.outputBuffer}catch(c){return this.outputBuffer.slice(0,b)}}};
Resampler.prototype.initializeBuffers=function(){try{this.outputBuffer=new Float32Array(this.outputBufferSize),this.lastOutput=new Float32Array(this.channels)}catch(b){this.outputBuffer=[],this.lastOutput=[]}};
//# sourceMappingURL=https://live.congrea.net/virtualclass/build/src/audio-g711
